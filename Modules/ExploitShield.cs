using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Text.RegularExpressions; // Added for Regex

namespace PhageVirus.Modules
{
    public class ExploitShield
    {
        // Windows API constants
        private const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
        private const uint MEM_COMMIT = 0x1000;
        private const uint MEM_RESERVE = 0x2000;
        private const uint PAGE_EXECUTE_READWRITE = 0x40;
        private const uint PAGE_EXECUTE_READ = 0x20;
        private const uint PAGE_READWRITE = 0x04;
        private const uint PAGE_GUARD = 0x100;
        private const uint PAGE_NOACCESS = 0x01;
        private const uint MEMORY_BASIC_INFORMATION_SIZE = 28;

        // Windows API structures
        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION
        {
            public IntPtr BaseAddress;
            public IntPtr AllocationBase;
            public uint AllocationProtect;
            public IntPtr RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        // Windows API functions
        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

        [DllImport("kernel32.dll")]
        private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, out int lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        private static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, uint dwLength);

        [DllImport("kernel32.dll")]
        private static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        private static extern bool CloseHandle(IntPtr hObject);

        [DllImport("kernel32.dll")]
        private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, int dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);

        // Exploit patterns
        private static readonly byte[] ShellcodePatterns = {
            // Common shellcode patterns
            0x90, 0x90, 0x90, 0x90, // NOP sled
            0xCC, 0xCC, 0xCC, 0xCC, // INT3 sled
            0xEB, 0xFE, // JMP $-2 (infinite loop)
            0xE9, 0x00, 0x00, 0x00, 0x00, // JMP instruction
            0xFF, 0xE4, // JMP ESP
            0xFF, 0xE0, // JMP EAX
            0xFF, 0xE1, // JMP ECX
            0xFF, 0xE2, // JMP EDX
            0xFF, 0xE3, // JMP EBX
            0xFF, 0xE5, // JMP EBP
            0xFF, 0xE6, // JMP ESI
            0xFF, 0xE7  // JMP EDI
        };

        private static readonly string[] ExploitStrings = {
            // Common exploit indicators
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", // Buffer overflow pattern
            "\\x90\\x90\\x90\\x90", // NOP sled string
            "\\xCC\\xCC\\xCC\\xCC", // INT3 sled string
            "\\xEB\\xFE", // JMP loop string
            "\\xFF\\xE4", // JMP ESP string
            "\\xE9", // JMP instruction string
            "\\x68", // PUSH instruction string
            "\\x68\\x65\\x6C\\x6C\\x6F", // "hello" string
            "\\x68\\x77\\x6F\\x72\\x6C\\x64", // "world" string
            "\\x68\\x73\\x68\\x65\\x6C\\x6C", // "shell" string
            "\\x68\\x63\\x6D\\x64", // "cmd" string
            "\\x68\\x2F\\x2F\\x73\\x68", // "//sh" string
            "\\x68\\x2F\\x62\\x69\\x6E", // "/bin" string
            "\\x68\\x2F\\x2F\\x62\\x69\\x6E", // "//bin" string
            "\\x68\\x2F\\x2F\\x2F\\x73\\x68", // "///sh" string
            "\\x68\\x2F\\x2F\\x2F\\x2F\\x73\\x68", // "////sh" string
            "\\x68\\x2F\\x2F\\x2F\\x2F\\x2F\\x73\\x68", // "/////sh" string
            "\\x68\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x73\\x68", // "//////sh" string
            "\\x68\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x73\\x68", // "///////sh" string
            "\\x68\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x2F\\x73\\x68" // "////////sh" string
        };

        private static readonly string[] ExploitTools = {
            "metasploit", "msfvenom", "msfconsole", "exploit", "payload",
            "shellcode", "buffer", "overflow", "rop", "gadget", "ret2libc",
            "aslr", "dep", "canary", "stack", "heap", "format", "string",
            "injection", "sql", "xss", "csrf", "lfi", "rfi", "xxe", "ssrf"
        };

        private static bool isActive = false;
        private static readonly object shieldLock = new object();

        public static void ActivateExploitShield()
        {
            if (isActive) return;

            lock (shieldLock)
            {
                if (isActive) return;

                try
                {
                    EnhancedLogger.LogInfo("Activating exploit shield...");
                    
                    // Start memory protection
                    Task.Run(() => ProtectMemoryRegions());
                    
                    // Start exploit detection
                    Task.Run(() => DetectExploits());
                    
                    // Start buffer overflow protection
                    Task.Run(() => MonitorBufferOverflows());
                    
                    isActive = true;
                    EnhancedLogger.LogSuccess("Exploit shield activated");
                }
                catch (Exception ex)
                {
                    EnhancedLogger.LogError($"Failed to activate exploit shield: {ex.Message}");
                }
            }
        }

        public static void DeactivateExploitShield()
        {
            lock (shieldLock)
            {
                if (!isActive) return;

                try
                {
                    isActive = false;
                    EnhancedLogger.LogInfo("Exploit shield deactivated");
                }
                catch (Exception ex)
                {
                    EnhancedLogger.LogError($"Failed to deactivate exploit shield: {ex.Message}");
                }
            }
        }

        private static void ProtectMemoryRegions()
        {
            while (isActive)
            {
                try
                {
                    var processes = Process.GetProcesses();
                    foreach (var process in processes)
                    {
                        try
                        {
                            if (process.Id == Process.GetCurrentProcess().Id) continue;

                            // Protect critical memory regions
                            ProtectProcessMemory(process);
                        }
                        catch
                        {
                            // Ignore processes we can't access
                        }
                    }

                    Thread.Sleep(10000); // Check every 10 seconds
                }
                catch (Exception ex)
                {
                    EnhancedLogger.LogWarning($"Memory protection error: {ex.Message}");
                    Thread.Sleep(15000);
                }
            }
        }

        private static void ProtectProcessMemory(Process process)
        {
            try
            {
                var processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, (uint)process.Id);
                if (processHandle == IntPtr.Zero) return;

                try
                {
                    var currentAddress = IntPtr.Zero;
                    var protectedRegions = 0;

                    while (true)
                    {
                        var mbi = new MEMORY_BASIC_INFORMATION();
                        var result = VirtualQueryEx(processHandle, currentAddress, out mbi, MEMORY_BASIC_INFORMATION_SIZE);
                        
                        if (result == 0) break;

                        // Protect executable memory regions
                        if (mbi.State == MEM_COMMIT && 
                            (mbi.Protect == PAGE_EXECUTE_READWRITE || mbi.Protect == PAGE_EXECUTE_READ))
                        {
                            // Check for suspicious content
                            if (IsSuspiciousMemoryRegion(processHandle, mbi.BaseAddress, (int)mbi.RegionSize))
                            {
                                // Apply additional protection
                                var oldProtect = 0u;
                                if (VirtualProtectEx(processHandle, mbi.BaseAddress, (int)mbi.RegionSize, PAGE_EXECUTE_READ, out oldProtect))
                                {
                                    protectedRegions++;
                                    EnhancedLogger.LogInfo($"Protected suspicious memory region in {process.ProcessName} at 0x{mbi.BaseAddress:X8}");
                                }
                            }
                        }

                        // Move to next region
                        currentAddress = IntPtr.Add(mbi.BaseAddress, (int)mbi.RegionSize);
                        
                        // Prevent infinite loop
                        if (currentAddress.ToInt64() <= mbi.BaseAddress.ToInt64())
                            break;
                    }

                    if (protectedRegions > 0)
                    {
                        EnhancedLogger.LogSuccess($"Protected {protectedRegions} memory regions in {process.ProcessName}");
                    }
                }
                finally
                {
                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogWarning($"Failed to protect memory for {process.ProcessName}: {ex.Message}");
            }
        }

        private static bool IsSuspiciousMemoryRegion(IntPtr processHandle, IntPtr baseAddress, int size)
        {
            try
            {
                var buffer = new byte[Math.Min(size, 4096)]; // Read up to 4KB
                var bytesRead = 0;

                if (!ReadProcessMemory(processHandle, baseAddress, buffer, buffer.Length, out bytesRead))
                    return false;

                if (bytesRead == 0) return false;

                // Check for shellcode patterns
                if (ContainsShellcodePatterns(buffer, bytesRead))
                    return true;

                // Check for exploit strings
                var content = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                if (ContainsExploitStrings(content))
                    return true;

                // Check for high entropy (packed/encrypted shellcode)
                if (CalculateEntropy(buffer, bytesRead) > 7.5)
                    return true;

                return false;
            }
            catch
            {
                return false;
            }
        }

        private static bool ContainsShellcodePatterns(byte[] buffer, int length)
        {
            for (int i = 0; i <= length - ShellcodePatterns.Length; i++)
            {
                bool match = true;
                for (int j = 0; j < ShellcodePatterns.Length; j++)
                {
                    if (buffer[i + j] != ShellcodePatterns[j])
                    {
                        match = false;
                        break;
                    }
                }
                if (match) return true;
            }
            return false;
        }

        private static bool ContainsExploitStrings(string content)
        {
            var lowerContent = content.ToLower();
            
            // Check for exploit tool indicators
            foreach (var tool in ExploitTools)
            {
                if (lowerContent.Contains(tool.ToLower()))
                    return true;
            }

            // Check for exploit string patterns
            foreach (var pattern in ExploitStrings)
            {
                if (lowerContent.Contains(pattern.ToLower()))
                    return true;
            }

            // Check for buffer overflow patterns
            if (Regex.IsMatch(content, @"A{20,}")) // Long sequence of 'A's
                return true;

            // Check for hex patterns
            if (Regex.IsMatch(content, @"\\x[0-9A-Fa-f]{2}"))
                return true;

            return false;
        }

        private static double CalculateEntropy(byte[] buffer, int length)
        {
            var frequency = new int[256];
            
            for (int i = 0; i < length; i++)
                frequency[buffer[i]]++;

            double entropy = 0;
            for (int i = 0; i < 256; i++)
            {
                if (frequency[i] > 0)
                {
                    double probability = (double)frequency[i] / length;
                    entropy -= probability * Math.Log(probability, 2);
                }
            }
            
            return entropy;
        }

        public static void DetectExploits()
        {
            while (isActive)
            {
                try
                {
                    var processes = Process.GetProcesses();
                    foreach (var process in processes)
                    {
                        try
                        {
                            if (process.Id == Process.GetCurrentProcess().Id) continue;

                            // Check for exploit indicators
                            CheckForExploitIndicators(process);
                        }
                        catch
                        {
                            // Ignore processes we can't access
                        }
                    }

                    Thread.Sleep(8000); // Check every 8 seconds
                }
                catch (Exception ex)
                {
                    EnhancedLogger.LogWarning($"Exploit detection error: {ex.Message}");
                    Thread.Sleep(12000);
                }
            }
        }

        private static void CheckForExploitIndicators(Process process)
        {
            try
            {
                var processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, (uint)process.Id);
                if (processHandle == IntPtr.Zero) return;

                try
                {
                    var currentAddress = IntPtr.Zero;
                    var exploitRegions = new List<string>();

                    while (true)
                    {
                        var mbi = new MEMORY_BASIC_INFORMATION();
                        var result = VirtualQueryEx(processHandle, currentAddress, out mbi, MEMORY_BASIC_INFORMATION_SIZE);
                        
                        if (result == 0) break;

                        // Check executable memory regions
                        if (mbi.State == MEM_COMMIT && 
                            (mbi.Protect == PAGE_EXECUTE_READWRITE || mbi.Protect == PAGE_EXECUTE_READ))
                        {
                            var regionSize = (int)mbi.RegionSize;
                            if (regionSize > 0 && regionSize <= 1024 * 1024) // Max 1MB
                            {
                                if (ContainsExploitCode(processHandle, mbi.BaseAddress, regionSize))
                                {
                                    exploitRegions.Add($"0x{mbi.BaseAddress:X8} (Size: {regionSize})");
                                }
                            }
                        }

                        // Move to next region
                        currentAddress = IntPtr.Add(mbi.BaseAddress, (int)mbi.RegionSize);
                        
                        // Prevent infinite loop
                        if (currentAddress.ToInt64() <= mbi.BaseAddress.ToInt64())
                            break;
                    }

                    if (exploitRegions.Count > 0)
                    {
                        EnhancedLogger.LogThreat($"Exploit code detected in {process.ProcessName} (PID: {process.Id}): {string.Join(", ", exploitRegions)}");
                        NeutralizeExploit(process, exploitRegions);
                    }
                }
                finally
                {
                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogWarning($"Exploit check failed for {process.ProcessName}: {ex.Message}");
            }
        }

        private static bool ContainsExploitCode(IntPtr processHandle, IntPtr baseAddress, int size)
        {
            try
            {
                var buffer = new byte[Math.Min(size, 8192)]; // Read up to 8KB
                var bytesRead = 0;

                if (!ReadProcessMemory(processHandle, baseAddress, buffer, buffer.Length, out bytesRead))
                    return false;

                if (bytesRead == 0) return false;

                // Check for shellcode patterns
                if (ContainsShellcodePatterns(buffer, bytesRead))
                    return true;

                // Check for exploit strings
                var content = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                if (ContainsExploitStrings(content))
                    return true;

                // Check for suspicious byte sequences
                if (ContainsSuspiciousByteSequences(buffer, bytesRead))
                    return true;

                return false;
            }
            catch
            {
                return false;
            }
        }

        private static bool ContainsSuspiciousByteSequences(byte[] buffer, int length)
        {
            // Check for common exploit byte sequences
            var suspiciousSequences = new byte[][]
            {
                new byte[] { 0x68, 0x65, 0x6C, 0x6C, 0x6F }, // "hello"
                new byte[] { 0x68, 0x77, 0x6F, 0x72, 0x6C, 0x64 }, // "world"
                new byte[] { 0x68, 0x73, 0x68, 0x65, 0x6C, 0x6C }, // "shell"
                new byte[] { 0x68, 0x63, 0x6D, 0x64 }, // "cmd"
                new byte[] { 0x68, 0x2F, 0x2F, 0x73, 0x68 }, // "//sh"
                new byte[] { 0x68, 0x2F, 0x62, 0x69, 0x6E }, // "/bin"
            };

            foreach (var sequence in suspiciousSequences)
            {
                for (int i = 0; i <= length - sequence.Length; i++)
                {
                    bool match = true;
                    for (int j = 0; j < sequence.Length; j++)
                    {
                        if (buffer[i + j] != sequence[j])
                        {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
            }

            return false;
        }

        private static void NeutralizeExploit(Process process, List<string> exploitRegions)
        {
            try
            {
                EnhancedLogger.LogWarning($"Neutralizing exploit in {process.ProcessName} (PID: {process.Id})");
                
                var processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, (uint)process.Id);
                if (processHandle == IntPtr.Zero) return;

                try
                {
                    foreach (var region in exploitRegions)
                    {
                        // Parse region address
                        var parts = region.Split(' ');
                        if (parts.Length >= 2)
                        {
                            var addressStr = parts[0].Replace("0x", "");
                            if (long.TryParse(addressStr, System.Globalization.NumberStyles.HexNumber, null, out long address))
                            {
                                var baseAddress = new IntPtr(address);
                                
                                // Overwrite with harmless code
                                var harmlessCode = new byte[1024]; // 1KB of harmless instructions
                                for (int i = 0; i < harmlessCode.Length; i += 4)
                                {
                                    harmlessCode[i] = 0x90; // NOP
                                    harmlessCode[i + 1] = 0x90; // NOP
                                    harmlessCode[i + 2] = 0x90; // NOP
                                    harmlessCode[i + 3] = 0xC3; // RET
                                }
                                
                                var bytesWritten = 0;
                                if (WriteProcessMemory(processHandle, baseAddress, harmlessCode, harmlessCode.Length, out bytesWritten))
                                {
                                    EnhancedLogger.LogSuccess($"Neutralized exploit region at 0x{address:X8} in {process.ProcessName}");
                                }
                            }
                        }
                    }
                }
                finally
                {
                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogError($"Failed to neutralize exploit in {process.ProcessName}: {ex.Message}");
            }
        }

        private static void MonitorBufferOverflows()
        {
            while (isActive)
            {
                try
                {
                    var processes = Process.GetProcesses();
                    foreach (var process in processes)
                    {
                        try
                        {
                            if (process.Id == Process.GetCurrentProcess().Id) continue;

                            // Check for buffer overflow indicators
                            CheckForBufferOverflow(process);
                        }
                        catch
                        {
                            // Ignore processes we can't access
                        }
                    }

                    Thread.Sleep(6000); // Check every 6 seconds
                }
                catch (Exception ex)
                {
                    EnhancedLogger.LogWarning($"Buffer overflow monitoring error: {ex.Message}");
                    Thread.Sleep(10000);
                }
            }
        }

        private static void CheckForBufferOverflow(Process process)
        {
            try
            {
                // Check for processes with suspicious memory patterns
                var processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, (uint)process.Id);
                if (processHandle == IntPtr.Zero) return;

                try
                {
                    var currentAddress = IntPtr.Zero;
                    var overflowDetected = false;

                    while (true)
                    {
                        var mbi = new MEMORY_BASIC_INFORMATION();
                        var result = VirtualQueryEx(processHandle, currentAddress, out mbi, MEMORY_BASIC_INFORMATION_SIZE);
                        
                        if (result == 0) break;

                        // Check for stack overflow patterns
                        if (mbi.State == MEM_COMMIT && mbi.Protect == PAGE_READWRITE)
                        {
                            var regionSize = (int)mbi.RegionSize;
                            if (regionSize > 0 && regionSize <= 4096) // Small regions (likely stack)
                            {
                                if (ContainsBufferOverflowPattern(processHandle, mbi.BaseAddress, regionSize))
                                {
                                    overflowDetected = true;
                                    EnhancedLogger.LogThreat($"Buffer overflow detected in {process.ProcessName} at 0x{mbi.BaseAddress:X8}");
                                    break;
                                }
                            }
                        }

                        // Move to next region
                        currentAddress = IntPtr.Add(mbi.BaseAddress, (int)mbi.RegionSize);
                        
                        // Prevent infinite loop
                        if (currentAddress.ToInt64() <= mbi.BaseAddress.ToInt64())
                            break;
                    }

                    if (overflowDetected)
                    {
                        // Take action against buffer overflow
                        HandleBufferOverflow(process);
                    }
                }
                finally
                {
                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogWarning($"Buffer overflow check failed for {process.ProcessName}: {ex.Message}");
            }
        }

        private static bool ContainsBufferOverflowPattern(IntPtr processHandle, IntPtr baseAddress, int size)
        {
            try
            {
                var buffer = new byte[Math.Min(size, 1024)]; // Read up to 1KB
                var bytesRead = 0;

                if (!ReadProcessMemory(processHandle, baseAddress, buffer, buffer.Length, out bytesRead))
                    return false;

                if (bytesRead == 0) return false;

                // Check for buffer overflow patterns
                var content = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                
                // Check for long sequences of 'A's (common buffer overflow pattern)
                if (Regex.IsMatch(content, @"A{50,}"))
                    return true;

                // Check for return address overwrites
                if (Regex.IsMatch(content, @"\x41{20,}")) // 20+ consecutive 0x41 bytes
                    return true;

                // Check for stack canary overwrites
                if (Regex.IsMatch(content, @"\x00{4,}")) // Multiple null bytes
                    return true;

                return false;
            }
            catch
            {
                return false;
            }
        }

        private static void HandleBufferOverflow(Process process)
        {
            try
            {
                // CRITICAL: Don't take aggressive action in VM environment
                if (IsVirtualMachine())
                {
                    EnhancedLogger.LogInfo($"Buffer overflow detected in {process.ProcessName} in VM - logging only");
                    return;
                }

                EnhancedLogger.LogWarning($"Handling buffer overflow in {process.ProcessName} (PID: {process.Id})");
                
                // Option 1: Kill the process (aggressive) - DISABLED IN VM
                // process.Kill();
                // EnhancedLogger.LogSuccess($"Terminated process with buffer overflow: {process.ProcessName}");
                
                // Option 2: Inject protection code (surgical) - DISABLED IN VM
                // InjectOverflowProtection(process);
                
                // Option 3: Log and monitor (passive) - SAFE FOR VM
                EnhancedLogger.LogInfo($"Buffer overflow logged for {process.ProcessName}: {process.Id}");
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogError($"Failed to handle buffer overflow in {process.ProcessName}: {ex.Message}");
            }
        }

        private static void InjectOverflowProtection(Process process)
        {
            // CRITICAL: Don't inject code in VM environment
            if (IsVirtualMachine())
            {
                EnhancedLogger.LogInfo($"Skipping overflow protection injection for {process.ProcessName} in VM environment");
                return;
            }

            try
            {
                EnhancedLogger.LogInfo($"Injecting overflow protection into {process.ProcessName} (PID: {process.Id})");
                
                var processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, (uint)process.Id);
                if (processHandle == IntPtr.Zero)
                {
                    EnhancedLogger.LogError($"Failed to open process {process.ProcessName}");
                    return;
                }

                try
                {
                    // Allocate memory for protection code
                    var protectionCode = CreateProtectionCode();
                    var allocatedMemory = VirtualAllocEx(processHandle, IntPtr.Zero, protectionCode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                    
                    if (allocatedMemory == IntPtr.Zero)
                    {
                        EnhancedLogger.LogError("Failed to allocate memory for protection code");
                        return;
                    }

                    // Write protection code to allocated memory
                    var bytesWritten = 0;
                    if (!WriteProcessMemory(processHandle, allocatedMemory, protectionCode, protectionCode.Length, out bytesWritten))
                    {
                        EnhancedLogger.LogError("Failed to write protection code to process");
                        return;
                    }

                    // Create remote thread to execute protection
                    var threadId = 0u;
                    var threadHandle = CreateRemoteThread(processHandle, IntPtr.Zero, 0, allocatedMemory, IntPtr.Zero, 0, out threadId);
                    
                    if (threadHandle != IntPtr.Zero)
                    {
                        EnhancedLogger.LogSuccess($"Overflow protection injected into {process.ProcessName} (Thread ID: {threadId})");
                        CloseHandle(threadHandle);
                    }
                    else
                    {
                        EnhancedLogger.LogError("Failed to create remote thread for overflow protection");
                    }
                }
                finally
                {
                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                EnhancedLogger.LogError($"Failed to inject overflow protection: {ex.Message}");
            }
        }

        private static byte[] CreateProtectionCode()
        {
            // Simple protection code that monitors for buffer overflows
            // In a real implementation, this would be more sophisticated
            var protectionCode = new List<byte>();
            
            // Add stack canary check
            protectionCode.AddRange(new byte[] { 0x90, 0x90, 0x90 }); // NOP sled
            protectionCode.AddRange(new byte[] { 0xCC }); // INT3 (breakpoint)
            protectionCode.AddRange(new byte[] { 0x90, 0x90, 0x90 }); // More NOPs
            protectionCode.AddRange(new byte[] { 0xC3 }); // RET
            
            return protectionCode.ToArray();
        }

        // Add VM detection method
        private static bool IsVirtualMachine()
        {
            try
            {
                // Check for common VM indicators
                using var computerSystem = new System.Management.ManagementObjectSearcher("SELECT * FROM Win32_ComputerSystem");
                foreach (System.Management.ManagementObject obj in computerSystem.Get())
                {
                    var manufacturer = obj["Manufacturer"]?.ToString()?.ToLower() ?? "";
                    var model = obj["Model"]?.ToString()?.ToLower() ?? "";
                    
                    if (manufacturer.Contains("vmware") || manufacturer.Contains("virtual") ||
                        manufacturer.Contains("microsoft") || manufacturer.Contains("parallels") ||
                        model.Contains("vmware") || model.Contains("virtual") ||
                        model.Contains("vbox") || model.Contains("parallels"))
                    {
                        return true;
                    }
                }
                return false;
            }
            catch
            {
                return false; // Assume not VM if detection fails
            }
        }

        public static bool IsActive => isActive;
    }
} 
